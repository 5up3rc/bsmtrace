#
# Define our logging channels
#
log-channel $syslog <syslog> {
	priority user.notice;
};

log-channel $bsm <bsm> {
	directory "/usr/bsm";
};

define set $my_log_channels <logchannel> {
	$bsm,
	$syslog;
};

#
# Define subject (or user) groupings
#
define set $fwadmins <auid> {
	alm,
	csjp;
};

#
# Define various event groups that we are interested in
#
define set $execution <auditevent> {
	AUE_EXEC,
	AUE_EXECVE;
};

define set $login <auditevent> {
	AUE_openssh,
	AUE_login,
	AUE_su;
};

#
# Define our object (or file) groups
#
define set $trusteddirs <path> {
	/bin,
	/sbin,
	/usr/bin,
	/usr/sbin,
	/usr/local/bin,
	/usr/X11R6/bin,
	/usr/local/sbin,
	/usr/games;
};

define set $opendirs <path> {
	/tmp,
	/var/tmp;
};

define set $fwtools <path> {
	/sbin/ipfw,
	/sbin/pfctl,
	/sbin/ipf;
};

############################################################
#
# Define our state machines or actual "IDS signatures"
#
############################################################

sequence firewall.change.attempt {
	subject not $fwadmins;
	log <logchannel> { $bsm; };
	state {
		event $execution;
		object $fwtools;
		status any;
	};
};

sequence non.trusted.exec {
	subject any;
	log <logchannel> { $bsm; };
	state {
		event $execution;
		object not $trusteddirs;
		trigger "/usr/bin/logger non.trusted.exec: $subject executed $object";
		status success;
	};
};

sequence mktemp.race {
	subject any;
	log <logchannel> { $bsm; };
	state {
		event <auditevent> { AUE_SYMLINK; };
		object $opendirs;
		status success;
	};
};

sequence login.brute.force {
	subject any;
	log <logchannel> { $bsm; };
	state {
		event $login;
		status failure;
		multiplier 5;
	};
	state {
		event $login;
		status success;
	};
};

sequence httpd.exec {
	subject <auid> { nobody; };
	log <logchannel> { $bsm; };
	state {
		event <auditevent> { AUE_SOCKET; };
		status success;
	};
	state {
		event <auditevent> { AUE_BIND; };
		status success;
	};
	state {
		event $execution;
		status any;
	};
};

sequence named.exec {
	subject <auid> { bind; };
	log <logchannel> { $bsm; };
	state {
		event <auditevent> { AUE_SOCKET; };
		status success;
	};
	state {
		event <auditevent> { AUE_BIND; };
		status success;
	};
	state {
		event $execution;
		status any;
	};
};

#
# Test for PCRE's
#
#sequence passwd.access {
#	subject any;
#	log <logchannel> { $bsm; };
#	state {
#		event <auditclass> { fr; };
#		status any;
#		object <pcre> { ^/etc/pass[Ww][Dd]; };
#	};
#};
#sequence etc.access {
#	subject any;
#	log <logchannel> { $bsm; };
#	state {
#		event <auditclass> { fr; };
#		status any;
#		object <pcre> { ^/[Ee][Tt][Cc]/*; };
#	};
#};
